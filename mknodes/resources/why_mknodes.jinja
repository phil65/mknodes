# Welcome to the **MkNodes** universe!

**MkNodes** can be used to improve the documentation generation process by providing a toolkit which empowers the user to:

## Move (parts of) the documentation generation into the python space.

**MkNodes** allows to easily switch between generating documentation programmatically and hand-writing documentation. You can basically decide for every single page yourself which "style" you gonna use, ranging from completely coding the documentation, over to "do-complex-parts-in-python-and-inject-the-result-into-jinja-namespace", or just the 100%-handwritten-Markdown approach. You could also just use **MkNodes** to generate some snippets for you (let's say a complicated dependency graph) and use that for your docs, without switching over to an MkNodes powered documentation.
**MkNodes** allows to easily switch between generating documentation programmatically and hand-writing documentation. You can basically decide for every single page yourself "how" you want to create it, ranging from completely coding the documentation, over to "do-complex-parts-in-python-and-inject-the-result-into-jinja-namespace", or just the 100%-handwritten-Markdown approach. You could also just use **MkNodes** to generate some markdown snippets for you (let's say a complicated dependency graph) and use that for your docs, without switching over to an **MkNodes** powered documentation.
You could also "parse" your existing files and `SUMMARY.mds` and extend these navigation trees by appending single navigation items via **MkNodes**. **MkNodes** even offers a special syntax to define **MkNodes** directly in your MkDocs.yml! (Undocumented feature in this moment though ;) )

That blend-in approach of course also works in the other direction. You can have the "skeleton" of your documentation written in python, and move to simple Markdown writing for the "text-heavy" pages. Other boilerplate stuff like tooling information, infos about dependencies, License, Changelog, all that stuff can get auto-generated by **MkNodes**, you just have to do the prose in Markdown.


## Easy access to more "advanced" customization options

Some customizations which are considered quite complex or time-consuming (like creating custom HTML page templates) become super easy all of a sudden! No need to mess with clunky HTML, no need to manage HTML files in a different folder in parallel. Just modify `MkPage.template` for any page with simple one-liners in order to trigger an automated template generation process, which also includes metadata / template inheritance if desired. And, yes, you can use Markdown in page templates! **MkNodes** will convert it to HTML for you during the build.
Read more about [page templates](Templates.md)!

## Manage your page using a declarative Python decorator routing API.

**MkNodes** makes it possible to create the "Navigation" core of your page using idiomatic python in form of decorator routing.
That approach feels a bit like a slightly more verbose version of writing `SUMMARY.md` files, with the added bonus that you can declare icons, subtitles, even templates at the same place where you also declare the menu title and "navigation path".

## Slim down your MkDocs config!

Since we operate in a highly dynamic python environment, a lot of markdown extensions become redundant.
No need for snippet/include related extensions, **jinja2** extensions can probably also get dropped, even the functionality of most CLI documentation extensions is covered. (supported right now: **argparse**, **Typer**, **Click**)


## Spend less energy on managing extensions and other assets

All **MkNodes** know about the required resources they need, like CSS, markdown extensions, Javascript libs and snippets, static assets like images etc.
During the build process, these resources get collected and put to the place where they belong, which could be the  **MkDocs** config, the build folder and / or the Page HTML head (using page templates). All that happens without requiring user / developer assitance.

!!! info
    Of course, that mechanism only works when **MkNodes** "knows" about the Markdown you used. That is the case when using **MkNodes** directly as Python objects, or by applying them as **jinja2** filters / macros using the [MkJinjaTemplate][mknodes.MkJinjaTemplate] node. In both cases, the resources get collected.
    What *won't* work: Adding markdown in text form as an [MkText][mknodes.MkText] node which needs resources, or when using [MkPage.from_file][mknodes.MkPage.from_file] or similar. **MkNodes** is not a parser, so it cant know which extensions etc. your Markdown needs in order to get rendered correctly. In that case you have to add the required extensions etc manually to the **MkDocs** config, like you did before.


## A powerful markdown-centered Jinja environment

You prefer to write Markdown instead of "coding" your docs? That's toally fine. Just use the [MkJinjaTemplate][mknodes.MkJinjaTemplate] node to be able to write Markdown in a all-batteries-included **jinja2** environment, with all information you need about your project available in the environment namespace. All available **MkNodes** (approx. 70) are available in the **jinja** environment right at your fingertips, in form of filters as well as globals. The nodes range from super simple MkHeader-nodes up to complex ones like MkTimeline, which makes use of JavaScript and dynamically generated CSS (without you noticing it!) or nodes composed of other nodes, spanning a complete page or more.
Take a look at the "Nodes" section to check them out!


## Create composable custom MkNodes and Website templates

**MkNodes** to create complex composable and re-usable "documentation widgets" in an easy way. It's super easy to write **MkNodes** composed of other **MkNodes**. Its even possible to create complete website templates and, by using the **MkNodes** CLI, apply them to packages in remote repositories. (this was mainly added for testing, but turns out that it's great fun!)


## A dead simple API

Working with **MkNodes** basically means: Create nodes, attach them to the tree and forget about them. That's it. No need for searching in overwhelming API docs, apart from the `__init__` signature, there really isnt much to learn about most nodes. Instantiate and attach using `+=` to a suiting container. Done.



*While MkNodes can be used as a standalone library, its advantages only really start to shine when combined with the **mkdocs-mknodes** addon for **MkDocs**. That plugin embeds the **MkNodes** tree building process into the **MkDocs** event hooks and also includes a CLI which allows to apply website build scripts to remote repositories.*
Check out the add-on [here](https://phil65.github.io/mkdocs_mknodes)!


Interested? Then take a look around!
The websites contain a lot of information, and the source code might also be worth looking at to get a feel how your final page could look like and how everyting works.
